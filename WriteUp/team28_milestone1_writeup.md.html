                    <meta charset="utf-8" emacsmode="-*- markdown -*">
                    **6.08 Final Project Week1 Write UP - Team 28**
        John Rao, Kameron Dawson, Camila Miranda-Llovera, Umang Bansal, Nick Dyette



Videos
===============================================================================

<iframe width="560" height="315" src="https://www.youtube.com/embed/mHC38co1NMg" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
<iframe width="560" height="315" src="https://www.youtube.com/embed/B3BJBKRPoR8" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
<iframe width="560" height="315" src="https://www.youtube.com/embed/TiSe5QtGjbk" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>

Deliverables
===============================================================================
Below is how we addressed each deliverable:

1. Create framework of phone
2. Creare Home app class
3. Create the UI for the Home Screen
4. Create a game app class
5. Create game UI
6. Create a messaging app class
7. Create a messaging UI

Messaging App
================================================================================
Specifications:

1. A messaging app the user can use to send messages to other users using a username
2. The user should be able to check message history with another user
3. The messaging app notifies the user when there are new messages

Server Side
-------------------------------------------------------------------------------
Requirements:

1. Handles different HTTP requests sent by the user and respond accordingly
  - Stores all messages sent by users in a database
  - Responds with message history between 2 users
  - Notifies the microcontroller when there are new messages

Implementation:

1. I created a database on the team server at *'/var/jail/home/team28/final_project/python/MessagingApp/'*. All HTTP requests for the messaging app would be addressed to *'http://608dev-2.net/sandbox/sc/team28/final_project/python/MessagingApp/messaging_server.py'*. Inside this database, we are keeping 2 separate tables for each user, one storing all messages a user sent and one storing all messages a user received. The names of the tables are generated on the server side once the HTTP request is received. Specifically, the user *username* would have a table called *usernameSENT* and *usernameRECEIVED*. 

2. The messaging app server handles both POST requests and GET requests. However, all user generated requests (to send a message or check messages) are all POST requests because we need to update the values in the table(discussed more in detail later). The only GET requests sent to the server should be the periodic checks for new messages sent by the microcontroller automatically. 

3. All POST requests sent by the user needs to have an argument *action* which tells the server what to look for next. When the user is sending a message, microcontroller sets *action = send*. When the user wants to check messages, the microcontroller sets *action = check*. If the user is sending a message, the microcontroller also asks the user to input the receiver's username and the message they want to send, and then the microcontroller generates the POST request with the required body *action=send&sender=(username of the sender)&receiver(username of the receiver)&message=(the message being sent)*. The server will then process this information and store the message in the corresponding tables (*senderSENT* and *receiverRECEIVED*) with a timestamp. The *usernameSENT* tables have 3 columns: *TIME_ timestamp, RECEIVER text, MESSAGE text* while the *usernameRECEIVED* tables has a additional columns: *READ text* to indicate whether the receiver has checked the message. This information is used when microcontroller sends the periodic GET requests to check for new messages. Once the message has being stored in the database properly, the server sends a confirmation back to the microcontroller. The code for send operation on the server is shown below:

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
if action == 'send':
  try:
    user_sender = request['form']['sender']
    user_receiver = request['form']['receiver']
    message = request['form']['message']
  except Exception as e:
    return e
  sender_table = user_sender + 'SENT'
  receiver_table = user_receiver + 'RECEIVED'
  with sqlite3.connect(messaging_db) as c:
    tableS_command = """CREATE TABLE IF NOT EXISTS {} (TIME_ timestamp, RECEIVER text, MESSAGE text);""".format(sender_table)
    tableR_command = """CREATE TABLE IF NOT EXISTS {} (TIME_ timestamp, SENDER text, MESSAGE text, READ text);""".format(receiver_table)
    c.execute(tableS_command)
    c.execute(tableR_command)
    insertS_command = """INSERT INTO {} VALUES (?,?,?);""".format(sender_table)
    insertR_command = """INSERT INTO {} VALUES (?,?,?,?);""".format(receiver_table)
    c.execute(insertS_command, (datetime.datetime.now(), user_receiver, message))
    c.execute(insertR_command, (datetime.datetime.now(), user_sender, message, 'NO'))
  return "Your message has been sent to {}!".format(user_receiver)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 

4. When the user wants to check messages, the microcontroller asks user for an username they want to check messages for and the number of messages they want to see, and then generates the POST request with the required body *action=check&me=(user checking)&other(username of the user wants to check messages for)&num=(number of messages the user wants to see)*. Once the server gets the POST response for checking messages, it first checks if these two users have previously sent or received messages(if the corresponding tables exist in the database). If these tables don't exist, the server responds "There are no messages between you and (other username)". If the server locates these tables, specifically *meSENT* and *meRECEIVED*, the server then selects the entries in *meSENT* where *RECEIVER=other* and the entries in *meRECEIVED* where the *SENDER=other*. Before sending these entries back to the microcontroller, the server combines the entries from these two tables and selects the specified number (by the user)of most recent messages and appends the corresponding sender of the message to the response. The server also updates the values in the *READ* column of *meRECEIVED* table to 'YES' (if they were previously marked as 'NO') for all messages being sent back to the microcontroller. Parts of the checking server code is shown here:

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
user_other = request['form']['other']
user_me = request['form']['me']
num_msg = int(request['form']['num'])

sent_table = user_me + 'SENT'
received_table = user_me + 'RECEIVED'
      
conn = sqlite3.connect(messaging_db)
c = conn.cursor()
queryS = """SELECT count(*) FROM sqlite_master WHERE type='table' AND name=?;"""
queryR = """SELECT count(*) FROM sqlite_master WHERE type='table' AND name=?;"""
tableS_count = c.execute(queryS, (sent_table,)).fetchone()
tableR_count = c.execute(queryR, (received_table,)).fetchone()
if tableS_count == 0 and tableR_count == 0:
  conn.commit()
  conn.close()
  return "There are no messages between you and {}!".format(user_other)

if tableR_count[0] != 0:
  check_received = """SELECT * FROM {} WHERE SENDER = ? ORDER BY TIME_ DESC;""".format(received_table)
  received_messages =  c.execute(check_received, (user_other,)).fetchall()
else:
  received_messages = []

if tableS_count[0] != 0:
  check_sent = """SELECT * FROM {} WHERE RECEIVER = ? ORDER BY TIME_ DESC;""".format(sent_table)
  sent_messages = c.execute(check_sent, (user_other,)).fetchall()
else:
  sent_messages = []
conn.commit()
conn.close()

with sqlite3.connect(messaging_db) as c:
  for msg in to_return:
    #here to_return is a list of messages being sent back to the microcontroller
    update_status = """ UPDATE {} SET READ = 'YES' WHERE READ = 'NO' AND TIME_ = ?;""".format(received_table)
    c.execute(update_status, (msg[0],))
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

5. We have also included the functionality for user to check all unread messages(if there are). This is done similar to the checking procedure detailed above. The only difference is that if the user chooses to check all unread messages, the microcontroller sets *other=UN_READ* in the POST request. This way the server knows to select all entries in *meRECEIVED* that has 'NO' in its *READ* column and update these to 'YES', then send back all entries to the microcontroller. Code shown below:

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
if user_other == 'UN_READ':
  with sqlite3.connect(messaging_db) as c:
    #on esp, make sure use can only check UN_READ when prompted there are unread messages (server is not checking if user received table exists)
    unread_query = """SELECT * FROM {} WHERE READ = 'NO' ORDER BY TIME_ DESC;""".format(received_table)
    unread_messages = c.execute(unread_query).fetchall()
    update_status = """ UPDATE {} SET READ = 'YES' WHERE READ = 'NO';""".format(received_table)
    c.execute(update_status)
    to_return = []
    for i in unread_messages:
      to_return.append([i[0], i[1]+':' + i[2]])
  return to_return
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

6. The server will respond to the periodic GET request sent by the microcontroller with the number of new messages that specified user has. The GET request would only have an argument *receiver=(the user using that device)*. The server checks *receiverRECEIVED* table and count the number of entries that have 'NO' in the the *READ* column. Code here:
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
user = request['values']['receiver']
  user_table = user + 'RECEIVED'
  with sqlite3.connect(messaging_db) as c:
    query = """SELECT * FROM {} WHERE READ = 'NO';""".format(user_table)
    num_unread = len(c.execute(query).fetchall())
  return num_unread
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

ESP UI
-------------------------------------------------------------------------------
Requirements:

1. User can select between sending and reading messages.
2. User receives notifications when they have new messages.
3. User can write and send their own messages to other users.
4. User can read their past messages with other users.

Implementation:

1. We created a state machine that consists of 4 states, a select menu state, a writing a message state, a selecting messages to read state, and a message displaying state. Upon entering our app, we start in the select menu state, and the user is prompted on the screen about the appropriate button inputs to transition into the other states. Our handle_user_input() function constantly checks for button presses and upon receiving the correct button inputs, causes the state machine to transition into the other states.

2. While in the select menu state, our system is periodically making a GET request to our messaging database checking for any messages that are unread through our checkUnreadNum() function. On the select menu screen, we have a line telling the user the amount of unread messages they currently have. The user is also prompted that upon pressing button 2 for a long time, they can read all their unread messages. This state transition can only occur though, if the number of unread messages is greater than 0.

3. Through pressing button 1, the user can transition to the message writing state. In this state, we interfaced with our keyboard input system to allow the user to type out their own messages within our 3 button system. We constantly call keyboard.handle_user_input() tracks the key that the user is currently on. We also display the currently typed word on the screen through calling keyboard.get_current_message(). We first prompt the user to type in their desired recepient of their message. Once the user presses enter, which is detected through keyboard.handle_user_input() returning True, we store the recepient in a variable and reset the keyboard through calling keyboard.reset_message(). We then prompt the user to enter their message. Once they press enter again, we store the message in a variable and we call our function sendMessage(other, message) which sends the appropriate POST request to the messaging database. 

4. Through short pressing button 2, the user transitions into the message selecting state. Similar to the send message state, we interface with the keyboard to allow the user to input the user whose messages they wish to see. Once they press enter, we store their input and then make the corresponding POST request to the database using our checkMessages() function, which then returns the last 10 messages between the two users. The messages are then displayed on the screen. 

Server Side
-------------------------------------------------------------------------------
Requirements:

1. User can select between sending and reading messages.
2. User receives notifications when they have new messages.
3. User can write and send their own messages to other users.
4. User can read their past messages with other users.

Implementation:

1. We created a state machine that consists of 4 states, a select menu state, a writing a message state, a selecting messages to read state, and a message displaying state. Upon entering our app, we start in the select menu state, and the user is prompted on the screen about the appropriate button inputs to transition into the other states. Our handle_user_input() function constantly checks for button presses and upon receiving the correct button inputs, causes the state machine to transition into the other states.

2. While in the select menu state, our system is periodically making a GET request to our messaging database checking for any messages that are unread through our checkUnreadNum() function. On the select menu screen, we have a line telling the user the amount of unread messages they currently have. The user is also prompted that upon pressing button 2 for a long time, they can read all their unread messages. This state transition can only occur though, if the number of unread messages is greater than 0.

3. Through pressing button 1, the user can transition to the message writing state. In this state, we interfaced with our keyboard input system to allow the user to type out their own messages within our 3 button system. We constantly call keyboard.handle_user_input() tracks the key that the user is currently on. We also display the currently typed word on the screen through calling keyboard.get_current_message(). We first prompt the user to type in their desired recepient of their message. Once the user presses enter, which is detected through keyboard.handle_user_input() returning True, we store the recepient in a variable and reset the keyboard through calling keyboard.reset_message(). We then prompt the user to enter their message. Once they press enter again, we store the message in a variable and we call our function sendMessage(other, message) which sends the appropriate POST request to the messaging database. 

4. Through short pressing button 2, the user transitions into the message selecting state. Similar to the send message state, we interface with the keyboard to allow the user to input the user whose messages they wish to see. Once they press enter, we store their input and then make the corresponding POST request to the database using our checkMessages() function, which then returns the last 10 messages between the two users. The messages are then displayed on the screen. 

Code Appendix
-------------------------------------------------------------------------------
Messaging App Server Python Code is Here:
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
import sqlite3
import datetime
import requests

messaging_db = '/var/jail/home/team28/final_project/python/MessagingApp/messages.db'

def request_handler(request):
  if request['method']=="POST":
    #use POST request to send messages and check old messages
    action = request['form']['action']

    if action == 'send':
    #if POST request is sending a message
    #POST request body should have arguments: action ('send'), sender, receiver, message
      try:
        user_sender = request['form']['sender']
        user_receiver = request['form']['receiver']
        message = request['form']['message']
      except Exception as e:
        return e
      #create two tables for each user ex. jhsraoSENT(for message jhsrao sent) and jhsraoRECEIVE
      sender_table = user_sender + 'SENT'
      receiver_table = user_receiver + 'RECEIVED'
      with sqlite3.connect(messaging_db) as c:
        #use formatted strings to handle table with variable name
        tableS_command = """CREATE TABLE IF NOT EXISTS {} (TIME_ timestamp, RECEIVER text, MESSAGE text);""".format(sender_table)
        #receiver tables have 1 extra column indicating whether the receiver has checked that message or not
        tableR_command = """CREATE TABLE IF NOT EXISTS {} (TIME_ timestamp, SENDER text, MESSAGE text, READ text);""".format(receiver_table)
        c.execute(tableS_command)
        c.execute(tableR_command)
        insertS_command = """INSERT INTO {} VALUES (?,?,?);""".format(sender_table)
        insertR_command = """INSERT INTO {} VALUES (?,?,?,?);""".format(receiver_table)
        c.execute(insertS_command, (datetime.datetime.now(), user_receiver, message))
        c.execute(insertR_command, (datetime.datetime.now(), user_sender, message, 'NO'))
      #sending complete return confirmation to user
      return "Your message has been sent to {}!".format(user_receiver)

    if action == 'check':
    #user wants to check a message
    #POST request body should have arguments: action ('check'), other(the user wants to check), me(the user checking), num(how many messages to check)
      try:
        user_other = request['form']['other']
        user_me = request['form']['me']
        num_msg = int(request['form']['num'])
      except Exception as e:
        return e
      #check both user_me's sent and received table
      sent_table = user_me + 'SENT'
      received_table = user_me + 'RECEIVED'
      #check all unread messages/ on esp, if user is checking all unread messages, send POST request action=check, other=='UN_READ', num=(number of unread)
      if user_other == 'UN_READ':
        with sqlite3.connect(messaging_db) as c:
          #on esp, make sure use can only check UN_READ when prompted there are unread messages (server is not checking if user received table exists)
          unread_query = """SELECT * FROM {} WHERE READ = 'NO' ORDER BY TIME_ DESC;""".format(received_table)
          unread_messages = c.execute(unread_query).fetchall()
          update_status = """ UPDATE {} SET READ = 'YES' WHERE READ = 'NO';""".format(received_table)
          c.execute(update_status)
          to_return = []
          for i in unread_messages:
            to_return.append([i[0], i[1]+':'+i[2]])
        return to_return
      #check message history with a specific user
      else:
        conn = sqlite3.connect(messaging_db)
        c = conn.cursor()
        #check if these tables exists
        queryS = """SELECT count(*) FROM sqlite_master WHERE type='table' AND name=?;"""
        queryR = """SELECT count(*) FROM sqlite_master WHERE type='table' AND name=?;"""
        # return 0 if table doesn't exist 1 otherwise
        tableS_count = c.execute(queryS, (sent_table,)).fetchone()
        tableR_count = c.execute(queryR, (received_table,)).fetchone()
        #if neither table exists there is no message history
        if tableS_count == 0 and tableR_count == 0:
          conn.commit()
          conn.close()
          return "There are no messages between you and {}!".format(user_other)
        
        if tableR_count[0] != 0:
          check_received = """SELECT * FROM {} WHERE SENDER = ? ORDER BY TIME_ DESC;""".format(received_table)
          received_messages =  c.execute(check_received, (user_other,)).fetchall()
        else:
          received_messages = []
        
        if tableS_count[0] != 0:
          check_sent = """SELECT * FROM {} WHERE RECEIVER = ? ORDER BY TIME_ DESC;""".format(sent_table)
          sent_messages = c.execute(check_sent, (user_other,)).fetchall()
        else:
          sent_messages = []
        conn.commit()
        conn.close()
        #order messages sent and received by time and only return the num user specfied
        to_return = []
        for i in range(num_msg):
          if len(sent_messages) >= 1 and len(received_messages) >= 1:
            if sent_messages[0] > received_messages[0]:
              selected = sent_messages.pop(0)
              to_insert = [selected[0], 'Me:'+ selected[2]]
              to_return.append(to_insert)
            elif received_messages[0] >= sent_messages[0]:
              selected = received_messages.pop(0)
              to_insert = [selected[0], user_other + ':'+selected[2]]
              to_return.append(to_insert)
          elif len(sent_messages) >= 1:
            selected = sent_messages.pop(0)
            to_insert = [selected[0], 'Me:'+ selected[2]]
            to_return.append(to_insert)
          elif len(received_messages) >= 1:
            selected = received_messages.pop(0)
            to_insert = [selected[0], user_other + ':'+ selected[2]]
            to_return.append(to_insert)
        '''to_return is a nested list = [['sender:', TIME_, MESSAGE ], "These are the last num messages between you and user_other"\
        or "There are only x messages between you and user_other"]'''
        with sqlite3.connect(messaging_db) as c:
          for msg in to_return:
            update_status = """ UPDATE {} SET READ = 'YES' WHERE READ = 'NO' AND TIME_ = ?;""".format(received_table)
            c.execute(update_status, (msg[0],))
        if len(to_return) < num_msg:
          to_return.append('There are only {} messages between you and {}.'.format(len(to_return), user_other))
        else:
          to_return.append('These are the last {} messages between you and {}.'.format(num_msg, user_other))
        return to_return

  else:
    #use GET request to periodically check if there are unread messagese
    #these GET request are automatically sent by esp every x seconds, only needs one argument
    #server should return number of unread messages
    user = request['values']['receiver']
    user_table = user + 'RECEIVED'
    with sqlite3.connect(messaging_db) as c:
      query = """SELECT * FROM {} WHERE READ = 'NO';""".format(user_table)
      num_unread = len(c.execute(query).fetchall())
    return num_unread

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
MessagingApp.cpp C++ Code is here:
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
#include "Arduino.h"
#include <TFT_eSPI.h> // Graphics and font library for ST7735 driver chip
#include <SPI.h> // Used in support of TFT Display
#include "Phone.h"
#include "App/App.h"
#include "MessagingApp.h"

MessagingApp::MessagingApp() {
    tft.fillScreen(TFT_BLACK);
    tft.setTextSize(1);
    tft.setTextColor(TFT_WHITE, TFT_BLACK); 
    text_state = 0;
    prev_state = 0;
    SELECT_MENU = 0;
    SEND_MESSAGE = 1;
    SELECT_MESSAGE = 2;
    DISPLAY_MESSAGE = 3;
    otherSelected = false;
    messageSelected = false;
    other[100];
    message[1000];
    firstTime = true;
    checkUnreadNum();
    unread_num = atoi(response);
    notif_period = 3000;
    timer = millis();
}

uint8_t MessagingApp::handle_user_input() {
    if (text_state == SELECT_MENU){
    if(button_input_one > 0){
      text_state = SEND_MESSAGE;
      prev_state = SELECT_MENU;
      otherSelected = false;
      messageSelected = false; 
    }
    else if(button_input_two == 1){
      text_state = SELECT_MESSAGE;
      prev_state = SELECT_MENU;
    }
    else if(button_input_two == 2 && unread_num > 0){
      checkUnreadMessages();
      text_state = DISPLAY_MESSAGE;
      prev_state = SELECT_MENU;
    }
        if(millis()-timer >= notif_period){
            checkUnreadNum();
            unread_num = atoi(response);
            timer = millis();
        }
    }
    else if(text_state== SEND_MESSAGE){ //Sending Messages
        if(keyboard.handle_user_input(button_input_one, button_input_two, button_input_three)){
          if (otherSelected == false){
            sprintf(other, "%s", keyboard.get_current_message());
            keyboard.reset_message();
            otherSelected = true;
          }else{
            sprintf(message, "%s", keyboard.get_current_message()); 
            keyboard.reset_message();
            sendMessage(other, message);
            otherSelected = false;
            text_state = DISPLAY_MESSAGE;
            prev_state = SEND_MESSAGE;
                    firstTime = true;
          }
        }
        }
    else if(text_state==SELECT_MESSAGE){ //Selecting which messages to see
        if(keyboard.handle_user_input(button_input_one, button_input_two, button_input_three)){
            sprintf(other, "%s", keyboard.get_current_message());
            keyboard.reset_message();
            checkMessages(other, 10);
            text_state = DISPLAY_MESSAGE;
            prev_state = SELECT_MESSAGE;
        }
    }
    else if(text_state==DISPLAY_MESSAGE){
        if(button_input_three == 1){
          text_state = SELECT_MENU;
          prev_state = DISPLAY_MESSAGE; 
        }
    }
    if (button_input_three == 2) {
        return 0; // switch to the home app
    } else {
        return 8; // stay on the messaging app
    } //Handling user inputs for texting select menu
}

void MessagingApp::sendMessage(char* other, char* message){
    char body[300];
    sprintf(body, "action=send&sender=user&receiver=%s&message=%s", other, message);
    http_request("POST",
        body,
        "http://608dev-2.net/sandbox/sc/team28/final_project/python/MessagingApp/messaging_server.py",
        "608dev-2.net");
}
void MessagingApp::checkUnreadMessages(){
    char body[300];
    sprintf(body, "action=check&other=UN_READ&me=user&num=10");
    http_request("POST",
        body,
        "http://608dev-2.net/sandbox/sc/team28/final_project/python/MessagingApp/messaging_server.py",
        "608dev-2.net");
}
void MessagingApp::checkMessages(char* other, int number){
    char body[300];
    sprintf(body, "action=check&other=%s&me=user&num=%d", other, number);
    http_request("POST",
        body,
        "http://608dev-2.net/sandbox/sc/team28/final_project/python/MessagingApp/messaging_server.py",
        "608dev-2.net");
}

void MessagingApp::checkUnreadNum(){
    char query[200];
    sprintf(query, "receiver=user");
    http_request("GET",
        query,
        "http://608dev-2.net/sandbox/sc/team28/final_project/python/MessagingApp/messaging_server.py",
        "608dev-2.net");
}

void MessagingApp::drawMessages(char* input, int yPos){
    tft.setCursor(5, yPos);
    tft.println(input);
  //tft.drawString(input, 5, yPos);
}

void MessagingApp::message_parsing(char* msg){
  char token = '\'';
  char delimiter[5];
  int yPos = 130;
  char* first_ptr = strchr(msg, '[')+3;
  sprintf(delimiter, "%c", token);
  char* ptr = strtok(first_ptr, delimiter);
  while(ptr != NULL){
    if(yPos < 0){
      break; 
    }
    if(strcmp(ptr, ", ")!=0&&strcmp(ptr, "], ")!=0&&strcmp(ptr, "], [")!=0&&strcmp(ptr,"]")&&strcmp(ptr, "]]")!=0){
      //drawMessages(ptr, yPos);
      tft.setCursor(5, yPos);
      tft.println(ptr);
      Serial.println(ptr);
      yPos -= 20; 
    }
    ptr = strtok(NULL, delimiter);
  }
} 

void MessagingApp::draw_screen() {
        //Serial.println(text_state);
      if(text_state==SELECT_MENU){
            if(prev_state != SELECT_MENU){
                tft.fillScreen(TFT_BLACK);
                prev_state = SELECT_MENU;
            }
            char notification[200];
            sprintf(notification, "%d new messages", unread_num);
            tft.drawString(notification, 20, 10);
            if(unread_num > 0){
                tft.drawString("Long press Button 2", 5, 30); 
                tft.drawString("to see new messages", 5, 40); 
            }
            else{
                tft.drawString("                      ", 5, 30); 
                tft.drawString("                      ", 5, 40); 
            }
        tft.drawString("Press Button 1", 25, 60);
            tft.drawString("to send a message", 15, 70);
        tft.drawString("Short Press Button 2", 5, 90);
            tft.drawString("to check history", 15, 100);
      }
      else if(text_state==SEND_MESSAGE){
            if(prev_state != SEND_MESSAGE){
                 tft.fillScreen(TFT_BLACK);
                 prev_state = SEND_MESSAGE;
            }
        keyboard.draw_screen();
        //Can put if statement before this, for if we print Recepient: or Message:
        tft.drawString(keyboard.get_current_message(), 10, 50);
        if(otherSelected == true && firstTime == true){
                tft.fillScreen(TFT_BLACK);
                firstTime = false;
                char draw_s[200];
                sprintf(draw_s, "Recepient: %s", other);
                tft.drawString(draw_s, 10, 30);
            }
      }
      else if(text_state==SELECT_MESSAGE){
            if(prev_state != SELECT_MESSAGE){
                tft.fillScreen(TFT_BLACK);
                prev_state = SELECT_MESSAGE;
            }
        keyboard.draw_screen();
        tft.drawString(keyboard.get_current_message(), 10, 50);
        if(otherSelected == true){
                char draw_s[200];
                sprintf(draw_s, "Recepient: %s", other);
          tft.drawString(draw_s, 10, 30);
        }
      }
      else if(text_state==DISPLAY_MESSAGE){
            if(prev_state != DISPLAY_MESSAGE){
                tft.fillScreen(TFT_BLACK);
            }
        if((prev_state == SELECT_MESSAGE) or (prev_state == SELECT_MENU)){
          message_parsing(response);
                //come back to fix parsing
        }
            else{
                tft.setCursor(10, 10);
                tft.println(response);
            }
            prev_state = DISPLAY_MESSAGE;
      }
    }
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
MessagingApp.h code is here:
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
#ifndef MessagingApp_h
#define MessagingApp_h
#include <TFT_eSPI.h> // Graphics and font library for ST7735 driver chip
#include <SPI.h> // Used in support of TFT Display
#include "Arduino.h"
#include "Phone.h"
#include "App/App.h"

class MessagingApp: public App {
    uint8_t text_state;
    uint8_t prev_state;
    uint8_t SELECT_MENU;
    uint8_t SEND_MESSAGE;
    uint8_t SELECT_MESSAGE;
    uint8_t DISPLAY_MESSAGE;
    bool otherSelected;
    bool messageSelected;
    bool firstTime;
    char other[100];
    char message[1000];
    int unread_num;
    uint32_t notif_period;
    int timer;

    public:
        MessagingApp();
        uint8_t handle_user_input();
        void draw_screen();
    private:
        void checkUnreadMessages();
        void checkMessages(char* other, int number);
        void sendMessage(char* other, char* message);
        void drawMessages(char* input, int yPos);
        void message_parsing(char* msg);
        void checkUnreadNum();
};

#endif
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Game App
================================================================================
Specifications:

1. The game should react to user inputs (button pushes)
2. The game should visually show user's progress 
3. The game class should store user's scores in database

Game UI 
-------------------------------------------------------------------------------

1. The game is as follows:
  - The user plays as a beach ball
  - The beach ball periodically encounters obstacles like birds and volleyball nets
  - The user must press a button to help the beach ball evade the obstacles, either by going under it (in the case of the bird) or over it (in the case of the bird or the volleyball net)
  - When the beach ball collides with an obstacle, the game is over
  - When the game is over, the user will see a message informing them the game is over and displaying their score
  - The user can short press the enter button to restart the game
  - The user can long press the enter button at any time to return to the home screen

2. Every time the user presses the button, the beach ball bounces up 20 pixels. This is accomplished in the handle_user_input function by subtracting 20 from the loc_y variable, which stores the y-coordinate of the upper-left hand corner of the ball, when the button is pressed. Otherwise, the ball lowers by 1 pixel (increments the loc_y variable by 1) due to gravity. The handle_user_input function is also responsible for updating the obstacles. Therefore, whenever obs1_x or obs2_x is off the screen, this function resets that variable to 127 and randomly chooses which obstacle will appear and at which y position. Otherwise, if an obstacle doesn't need to be reset, this function decrements their x coordinate by 1 so they constantly move to the left. 

3. The draw_screen function is responsible for showing the beach ball and the obstacles immediately before or after it. It also checks for collisions by using a similar strategy as in Regular Exercise 6. This function treats the beach ball and all obstacles as squares and checks for overlaps. In the case of an overlap, the draw_screen function calls reset().

4. The reset function draws the GAME OVER screen, including the user's final score, then makes a POST request to the score database, with the body containing the user's current score. The request handler in score_database.py adds the score to a table of the user's previous scores. If the current score is highest in the table, it returns "You beat your highest score". Otherwise, it returns "your highest score was ", followed by the user's highest score. The reset function receives this string and prints it to the screen. It then re-initializes the score to be 0, the beach ball's location to be the middle of the screen and the obstacles to appear at the right hand of the screen at random heights.

Code Appendix
-------------------------------------------------------------------------------
GameApp.cpp C++ code:
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
#include "Arduino.h"
#include <TFT_eSPI.h> // Graphics and font library for ST7735 driver chip
#include <SPI.h> // Used in support of TFT Display
#include "Phone.h"
#include "App/App.h"
#include "GameApp.h"
#include "stdlib.h"
#include "math.h"

#include "App/Apps/GameApp/game_images/bird.h"
#include "App/Apps/GameApp/game_images/volley_image.h"
#include "App/Apps/GameApp/game_images/volleyball_image.h"

GameApp::GameApp() {  
    // background color
    tft.fillScreen(TFT_WHITE);
    tft.setTextSize(1);
    tft.setTextColor(TFT_BLACK, TFT_WHITE); // set color of font to black foreground, white background
    loc_y = 82;
    loc_x = 30;
    obs1_x = 127;
    obs2_x = 191;
    choose1 = random(2);
    choose2 = random(2);
    score = 0;
    done1 = false;
    done2 = false;
    game_over[25] = {NULL};
    scorestring[20] = {NULL};
    if (choose1 == 0) {
      obs1_y = random(82) + 82;
      obs1_height = volley_height;
      obs1_width = volley_width;
    } else {
      obs1_y = random(82);
      obs1_height = bird_height;
      obs1_width = bird_width;
    }
    if (choose2 == 0) {
      obs2_y = random(82) + 82;
      obs2_height = volley_height;
      obs2_width = volley_width;
    } else {
      obs2_y = random(82);
      obs2_height = bird_height;
      obs2_width = bird_width;
    }
}

uint8_t GameApp::handle_user_input() {
  if (button_input_two == 1) {
      if (loc_y >= 20) {
        loc_y -= 20;
      } else {
        loc_y = 0;
      }
    }
    obs1_x -= 1;
    obs2_x -= 1;
    if (obs1_x <= -obs1_width) {
      choose1 = random(2);
      if (choose1 <= 0) {
        obs1_y = random(82) + 82;\
        obs1_height = volley_height;
        obs1_width = volley_width;
      } else {
        obs1_y = random(82);
        obs1_height = bird_height;
        obs1_width = bird_width;
      }
      obs1_x = 127;
    }
    if (obs2_x <= -obs2_width) {
      choose2 = random(2);
      if (choose2 <= 0) {
        obs2_y = random(82) + 82;
        obs2_height = volley_height;
        obs2_width = volley_width;
      } else {
        obs2_y = random(82);
        obs2_height = bird_height;
        obs2_width = bird_width;
      }
      obs2_x = 127;
    }
    loc_y += 1;
    if (button_input_three == 1) {
        over = false;
        loc_y = 82;
        loc_x = 64;
        obs1_y;
        obs1_x = 127;
        obs1_height;
        obs1_width;
        obs2_y;
        obs2_x = 191;
        obs2_height;
        obs2_width;
        choose1 = random(2);
        choose2 = random(2);
        memset(game_over, 0, strlen(game_over));
        if (choose1 <= 0.5) {
            obs1_y = random(82) + 82;
            obs1_height = volley_height;
            obs1_width = volley_width;
        } else {
            obs1_y = random(82);
            obs1_height = bird_height;
            obs1_width = bird_width;
        }
        if (choose2 <= 0.5) {
            obs2_y = random(82) + 82;
            obs2_height = volley_height;
            obs2_width = volley_width;
        } else {
            obs2_y = random(82);
            obs2_height = bird_height;
            obs2_width = bird_width;
        }
        score = 0;
    }
    if (button_input_three == 2) {
        return 0; // switch to the home app
    } else {
        return 8; // stay on the game app
    }
}

void GameApp::draw_screen() {
    if (!over) {
        tft.fillScreen(TFT_WHITE);
        tft.pushImage(loc_x, loc_y, volleyball_width, volleyball_height, volleyball);
        if (choose1 <= 0.5) {
          tft.pushImage(obs1_x, obs1_y, volley_width, volley_height, volleynet);
        } else {
          tft.pushImage(obs1_x, obs1_y, bird_width, bird_height, bird);
        }
        if (choose2 <= 0.5) {
          tft.pushImage(obs2_x, obs2_y, volley_width, volley_height, volleynet);
        } else {
          tft.pushImage(obs2_x, obs2_y, bird_width, bird_height, bird);
        } 

        if (loc_x < obs1_x) { // ball before obstacle 1
          if (loc_x + volleyball_width - 6 > obs1_x) {
            if (choose1 == 0) {
              if (loc_y + volleyball_height - 6 > obs1_y) {
                        over = true;
                reset();
              }
            } else {
              if (loc_y > obs1_y) {
                if (obs1_y + obs1_height - 6 > loc_y) {
                            over = true;
                  reset();
                }
              } else {
                if (loc_y + volleyball_height - 6 > obs1_y) {
                            over = true;
                  reset();
                }
              }
            }
            if (!done1) {
              score += 1;
            }
            done1 = true;
          } else {
            done1 = false;
          }
        } else { // ball at or after obstacle 1
          if (loc_x < obs1_x + obs1_width) { // ball at obstacle
            if (choose1 == 0) {
              if (loc_y + volleyball_height - 6 > obs1_y) {
                        over = true;
                reset();
              }
            } else {
              if (loc_y > obs1_y) {
                if (obs1_y + obs1_height - 6 > loc_y) {
                            over = true;
                  reset();
                }
              } else {
                if (loc_y + volleyball_height - 6 > obs1_y) {
                            over = true;
                  reset();
                }
              }
            }
            if (!done1) {
              score += 1;
            }
            done1 = true;
          } else {
            done1 = false;
          }
        }

        if (loc_x < obs2_x) { // ball before obstacle 1
          if (loc_x + volleyball_width - 6 > obs2_x) {
            if (choose2 == 0) {
              if (loc_y + volleyball_height - 6 > obs2_y) {
                        over = true;
                reset();
              }
            } else {
              if (loc_y > obs2_y) {
                if (obs2_y + obs2_height - 6 > loc_y) {
                            over = true;
                  reset();
                }
              } else {
                if (loc_y + volleyball_height - 6 > obs2_y) {
                            over = true;
                  reset();
                }
              }
            }
            if (!done2) {
              score += 1;
            }
            done2 = true;
          } else {
            done2 = false;
          } 
        } else { // ball at or after obstacle 1
          if (loc_x < obs2_x + obs2_width) { // ball at obstacle
            if (choose2 == 0) {
              if (loc_y + volleyball_height - 6 > obs2_y) {
                        over = true;
                reset();
              }
            } else {
              if (loc_y > obs2_y) {
                if (obs2_y + obs2_height - 6 > loc_y) {
                            over = true;
                  reset();
                }
              } else {
                if (loc_y + volleyball_height - 6 > obs2_y) {
                            over = true;
                  reset();
                }
              }
                }
            if (!done2) {
              score += 1;
            }
            done2 = true;
          } else {
            done2 = false;
          }
        }

        if (loc_y >= 164) {
            over = true;
            reset();
        }
    }    
}

void GameApp::reset() {
  sprintf(game_over, "GAME OVER\nSCORE: %d", score);
  tft.fillScreen(TFT_BLACK);
  tft.setTextSize(1);
    tft.setTextColor(TFT_WHITE, TFT_BLACK); 
    tft.drawString(game_over, 5, 75);
    memset(scorestring, 0, strlen(scorestring));
    sprintf(scorestring, "score=%d", score);
    http_request("POST", scorestring, "/sandbox/sc/team28/final_project/python/GamesApp/score_database.py", "608dev-2.net");
    tft.setCursor(5, 85);
    tft.println(response);
    loc_y = 82;
    loc_x = 64;
    obs1_y;
    obs1_x = 127;
    obs1_height;
    obs1_width;
    obs2_y;
    obs2_x = 191;
    obs2_height;
    obs2_width;
    choose1 = random(2);
    choose2 = random(2);
    memset(game_over, 0, strlen(game_over));
    if (choose1 <= 0.5) {
      obs1_y = random(82) + 82;
      obs1_height = volley_height;
      obs1_width = volley_width;
    } else {
      obs1_y = random(82);
      obs1_height = bird_height;
      obs1_width = bird_width;
    }
    if (choose2 <= 0.5) {
      obs2_y = random(82) + 82;
      obs2_height = volley_height;
      obs2_width = volley_width;
    } else {
      obs2_y = random(82);
      obs2_height = bird_height;
      obs2_width = bird_width;
    }
}
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
GameApp.h C++ code:
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
/*
  GameApp.h - Library for the GameApp child class of App.
              Allows users to play a video game.
*/
#ifndef GameApp_h
#define GameApp_h
#include <TFT_eSPI.h> // Graphics and font library for ST7735 driver chip
#include <SPI.h> // Used in support of TFT Display
#include "Arduino.h"
#include "Phone.h"
#include "App/App.h"

class GameApp: public App {
  private: 
    int loc_y;
      int loc_x;
      int obs1_y;
      int obs1_x;
      int obs1_height;
      int obs1_width;
      int obs2_y;
      int obs2_x;
      int obs2_height;
      int obs2_width;
      int choose1;
      int choose2;
      int score;
      bool done1;
      bool done2;
      char game_over[25];
      bool over;
      char scorestring[20];
    public:
        GameApp();
        uint8_t handle_user_input();
        void draw_screen();
    private: 
        void reset();
};

#endif
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
score_database.py Python code
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
import requests
import datetime
import sqlite3

db = '/var/jail/home/team28/final_project/stockdatabase.db'

def request_handler(request):
  
    
  if request["method"] == "POST":
    best_score = 0
    
    conn = sqlite3.connect(db)  # connect to that database (will create if it doesn't already exist)
    c = conn.cursor()  # move cursor into database (allows us to execute commands)
    outs = ""
    c.execute('''CREATE TABLE IF NOT EXISTS score_table (score real, timing timestamp);''') # run a CREATE TABLE command
    
    if 'score' not in request['form']:
      return "missing a value"
    
    try:
      score = int(request['form']['score'])
      
    except ValueError:
      # return e here or use your own custom return message for error catch
      #be careful just copy-pasting the try except as it stands since it will catch *all* Exceptions not just ones related to number conversion.
      return "Error: score is not a number"
    
    c.execute('''INSERT into score_table VALUES (?,?);''', (score,datetime.datetime.now()))
    things = c.execute('''SELECT score FROM score_table;''').fetchall()
    
    for i in range(len(things)):
      if things[i][0] > best_score:
        best_score = things[i][0]
        
    conn.commit() # commit commands
    conn.close() # close connection to database
    
    if score == best_score:
      return "You beat your high score!"
    else:
      return "Your high score was {}".format(best_score)
    
  else:
    return 'GET not supported. You need to change that.'
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Home Screen App
================================================================================
Specifications:

1. The user should be able to view icons representing the apps available
2. The user should be able to navigate the screen using buttons
3. The screen should reflect the user's choice by inverting the icon of the chosen app
4. When the user presses the enter button, the Phone should move to the chosen app's class

Home Screen UI 
-------------------------------------------------------------------------------
1. The Home Screen works as follows: 
  - 7 icons are displayed on the screen
  - There exist three buttons: 
    - Button 1 maneuvers horizontally
    - Button 2 maneuvers vertically
    - Button 3 is an enter button
  - When the user presses Buttons 1 or 2, the Home Screen should invert the colors of the selected icon to reflect the user's choice
  - When the user presses Button 3, the Phone should exit the Home Screen class and enter the selected app's class

2. The handle_user_input functions handles the user's inputs and makes the appropriate changes. If buttons 1 or 2 are pushed, it updates the state variables, which reflect where on the screen the user is currently selecting an icon. If button 3 is pushed, this function returns a number corresponding to the selected app. For example, a 0 corresponds to the Home Screen app, while a 5 corresponds to the Game app. If button 3 is not pushed, this function returns an 8, which indicates to remain in the home app class. 

3. The draw_screen function displays icons on the screen. If an icon is not selected (selection is determined by state variables), the draw_screen function uses the tft.pushImage function to display the regular version of the icon. If the icon is selected, the function instead displays a version of that icon where every pixel that was normally black is now white and every pixel that was white is now black. 

Code Appendix
-------------------------------------------------------------------------------
HomeApp.cpp C++ Code
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
#include "Arduino.h"
#include <TFT_eSPI.h> // Graphics and font library for ST7735 driver chip
#include <SPI.h> // Used in support of TFT Display
#include "Phone.h"
#include "App/App.h"
#include "HomeApp.h"
// app icons
#include "App/Apps/HomeApp/Images/clock.h"
#include "App/Apps/HomeApp/Images/game.h"
#include "App/Apps/HomeApp/Images/internet.h"
#include "App/Apps/HomeApp/Images/mail.h"
#include "App/Apps/HomeApp/Images/messaging.h"
#include "App/Apps/HomeApp/Images/music.h"
#include "App/Apps/HomeApp/Images/weather.h"

HomeApp::HomeApp() {  
    horizontal_select_state = 0;
    vertical_select_state = 0;
    current_app = 8;
    // background color
    tft.fillScreen(TFT_HOME_SCREEN);
    // initial render of the screen
    draw_screen();
}

uint8_t HomeApp::handle_user_input() {
  if (button_input_two == 1 || button_input_two == 2) {
    // vertical scroll
    if (vertical_select_state == 0) {
      vertical_select_state++;
    } else if (vertical_select_state == 1) {
      vertical_select_state++;
      horizontal_select_state = 0;
    } else {
      vertical_select_state = 0;
    }
  }
  if (button_input_one == 1 || button_input_one == 2) {
    // horizontal scroll
    if (vertical_select_state != 2 && horizontal_select_state < 2) {
      horizontal_select_state++;
    } else {
      horizontal_select_state = 0;
    }
  }
  current_app = 1 + horizontal_select_state + vertical_select_state*3;
  if (button_input_three == 1 || button_input_three == 2) {
    // enter an app
    return current_app; // switch to the app entered
  } else {
    return 8; // stay on the home app
  }
}

void HomeApp::draw_screen() {
    // first row
    if (current_app != MESSAGING) {
        tft.pushImage(8, 16, messaging_icon_width, messaging_icon_height, messaging_icon);
    } else {
        tft.pushImage(8, 16, messaging_icon_width, messaging_icon_height, messaging_icon_inverted);
    }
    if (current_app != MAIL) {
        tft.pushImage(48, 16, mail_icon_width, mail_icon_height, mail_icon);
    } else {
        tft.pushImage(48, 16, mail_icon_width, mail_icon_height, mail_icon_inverted);
    }
    if (current_app != CLOCK) {
        tft.pushImage(88, 16, clock_icon_width, clock_icon_height, clock_icon);
    } else {
        tft.pushImage(88, 16, clock_icon_width, clock_icon_height, clock_icon_inverted);
    }
    // second row
    if (current_app != WEATHER) {
        tft.pushImage(8, 64, weather_icon_width, weather_icon_height, weather_icon);
    } else {
        tft.pushImage(8, 64, weather_icon_width, weather_icon_height, weather_icon_inverted);
    }
    if (current_app != GAME) {
        tft.pushImage(48, 64, game_icon_width, game_icon_height, game_icon);
    } else {
        tft.pushImage(48, 64, game_icon_width, game_icon_height, game_icon_inverted);
    }
    if (current_app != MUSIC) {
        tft.pushImage(88, 64, music_icon_width, music_icon_height, music_icon);
    } else {
        tft.pushImage(88, 64, music_icon_width, music_icon_height, music_icon_inverted);
    }
    // third row
    if (current_app != INTERNET) {
        tft.pushImage(8, 112, internet_icon_width, internet_icon_height, internet_icon);
    } else {
        tft.pushImage(8, 112, internet_icon_width, internet_icon_height, internet_icon_inverted);
    }
}
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
HomeApp.h C++ Code
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
/*
  HomeApp.h - Library for the HomeApp child class of App.
              Displays the available apps for the user to access.
*/
#ifndef HomeApp_h
#define HomeApp_h
#include <TFT_eSPI.h> // Graphics and font library for ST7735 driver chip
#include <SPI.h> // Used in support of TFT Display
#include "Arduino.h"
#include "Phone.h"
#include "App/App.h"

class HomeApp: public App {
    private:
        uint8_t horizontal_select_state;
        uint8_t vertical_select_state;
        uint8_t current_app;
    public:
        HomeApp();
        uint8_t handle_user_input();
        void draw_screen();
};

#endif
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Framework of Phone
================================================================================
Specifications:

1. Memory allocation, user input, outputting to screen, and http requests should all be generalized and contained in a generic App class to prevent repeated code.
2. The structure of all apps should be the same to make development and integration easier.
3. State machine to handle switching between apps based on user input.
4. Create reusable utility classes like Button and Keyboard.

Framework
-------------------------------------------------------------------------------
1. The framework works as follows: 
  - An instance of Phone class is created at the start of the Arduino code that contains the phone state machine and an instance of the current App class.
    - The App class contain three utility methods: get_user_input, handle_user_input, and draw_screen. 
    - The first method is the same for all subclasses of App and the other two are meant to be overridden by subclasses of App.
  - The phone object has one function called loop that is called on every iteration of the loop in the main Arduino file.
    - the app's get_user_input is called first and the button values are stored in the app parent class, which is available to child classes
    - the app's handle_user_input is called second and the implementation is up to the child classes, but this is where subclasses of App change their internal state based on user input
    - handle_user_input returns a number indicating the app we should switch to: the Home app class returns numbers 1 to 7 for apps selected by the user, all non-Home app classes return 0 to switch to the Home app if a long press is registered on button 3, and all classes return 8 if we should remain on the current app
    - the app's draw_screen is called last and the implementation is up to the child classes, but this is where subclasses of App output to the screen
2. The button class is the one from class. When get_user_input is called it calls the function update_state for each button, which updates the button's internal state but also returns a flag: 0 for no press, 1 for short press, and 2 for long press.
3. The keyboard has four public methods: handle_user_input, get_current_message, reset_message, and draw_screen. 
    - The first is called by other classes when they want the user to be able to enter characters on a keyboard. The function changes the keyboard state based on user inputs.
    - The second is called by other classes to get the currently entered message.
    - The third is called by other classes to reset the current message when the user is done entering characters.
    - The fourth is called to output the UI of the keyboard to the screen.

Code Appendix
-------------------------------------------------------------------------------
Phone.cpp C++ Code
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
#include "Arduino.h"
#include <memory>
#include <TFT_eSPI.h> // Graphics and font library for ST7735 driver chip
#include <SPI.h> // Used in support of TFT Display
#include "Phone.h"
#include "App/App.h"
// apps
#include "App/Apps/HomeApp/HomeApp.h"
#include "App/Apps/MessagingApp/MessagingApp.h"
#include "App/Apps/MailApp/MailApp.h"
#include "App/Apps/ClockApp/ClockApp.h"
#include "App/Apps/WeatherApp/WeatherApp.h"
#include "App/Apps/GameApp/GameApp.h"
#include "App/Apps/MusicApp/MusicApp.h"
#include "App/Apps/InternetApp/InternetApp.h"

Phone::Phone() {
    state = HOME; // default state is the home app
    setup(); // sets up the lcd screen, buttons, and serial
    app = std::unique_ptr<App>(new HomeApp()); // create an instance of HomeApp
}

void Phone::setup() {
    // screen setup
    tft.init();  // init lcd screen
    tft.setRotation(2); // adjust rotation
    tft.fillScreen(TFT_WHITE); // fill background

    // serial setup
    Serial.begin(115200); // initialize serial to communicate with the serial monitor

    // button setup
    pinMode(19, INPUT_PULLUP); // set IO pin 3, 5, and 19 as inputs which default to a 3.3V signal when unconnected and 0V when the switch is pushed
    pinMode(5, INPUT_PULLUP);
    pinMode(3, INPUT_PULLUP);
}

void Phone::loop() {
    app->get_user_input(); // get the button input values
    uint8_t new_state = app->handle_user_input(); // handle the button input and return if the state has changed
    if (new_state != NO_CHANGE && state != new_state) {
        state = new_state;
        switch (state) {
            case HOME:
                app = std::unique_ptr<App>(new HomeApp());
                break;
            case MESSAGING:
                app = std::unique_ptr<App>(new MessagingApp());
                break;
            case MAIL:
                app = std::unique_ptr<App>(new MailApp());
                break;
            case CLOCK:
                app = std::unique_ptr<App>(new ClockApp());
                break;
            case WEATHER:
                app = std::unique_ptr<App>(new WeatherApp());
                break;
            case GAME:
                app = std::unique_ptr<App>(new GameApp());
                break;
            case MUSIC:
                app = std::unique_ptr<App>(new MusicApp());
                break;
            case INTERNET:
                app = std::unique_ptr<App>(new InternetApp());
                break;
            default:
                app = std::unique_ptr<App>(new HomeApp());
                break;
        }
    }
    app->draw_screen(); // draw the screen based off of the app and its state machine
}
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Phone.h C++ Code
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
/*
  Phone.h - Library for the Phone class. Handles the state machine and memory
            allocation for the phone. Stores an instance of the current app open.
*/
#ifndef TFT_HOME_SCREEN
#define TFT_HOME_SCREEN 0x6dbf
#endif

#ifndef Phone_h
#define Phone_h
#include <memory>
#include "Arduino.h"
#include <TFT_eSPI.h> // Graphics and font library for ST7735 driver chip
#include <SPI.h> // Used in support of TFT Display
#include "App/App.h"
#include "App/Inputs/Button/Button.h"
#include "App/Inputs/Keyboard/Keyboard.h"

// screen
static TFT_eSPI tft = TFT_eSPI();

// buttons
static Button button_one = Button(19);
static Button button_two = Button(5);
static Button button_three = Button(3);

// keyboard
static Keyboard keyboard = Keyboard();

// phone states
static const uint8_t HOME = 0;
static const uint8_t MESSAGING = 1;
static const uint8_t MAIL = 2;
static const uint8_t CLOCK = 3;
static const uint8_t WEATHER = 4;
static const uint8_t GAME = 5;
static const uint8_t MUSIC = 6;
static const uint8_t INTERNET = 7;
static const uint8_t NO_CHANGE = 8;

class Phone {
    private:
        uint8_t state;
        std::unique_ptr<App> app;
        void setup();
        void connect_to_internet();
    public:
        Phone();
        void loop();
};

#endif
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
App.cpp C++ Code
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
#include <memory>
  #include <string.h> // Library to manipulate strings
  #include "Arduino.h"
  #include <WiFi.h> // Connect to WiFi Network
  #include "Phone.h"
  #include "App.h"
  #include "Inputs/Button/Button.h"
  
  App::App() {
    // user button inputs
    button_input_one = 0;
    button_input_two = 0;
    button_input_three = 0;
  }
  
  void App::get_user_input() {
    button_input_one = button_one.update_state();
    button_input_two = button_two.update_state();
    button_input_three = button_three.update_state();
  }
  
  uint8_t App::handle_user_input() {
    if (button_input_three == 2) {
      return 0; // return to the home app
    } else {
      return 8; // stay on the current app
    }
  }
  
  void App::draw_screen() {
    Serial.println("Parent class draw screen");
  }
  
  void App::http_request(char* type, char* body, char* destination, char* host) {
    // the host, destination, type, body, will be determined by the different app that needs to send a request
    const uint16_t IN_BUFFER_SIZE = 1000;
    char request_buffer[IN_BUFFER_SIZE];
    int offset = 0;
    if (strcmp(type, "GET") == 0) {
      if (strlen(body) > 0) {
        offset += sprintf(request_buffer + offset, "GET %s?parameter=%s HTTP/1.1\r\n", destination, body);
      } else {
        offset += sprintf(request_buffer + offset, "GET %s HTTP/1.1\r\n", destination);
      }
      offset += sprintf(request_buffer + offset, "Host: %s\r\n", host);
      offset += sprintf(request_buffer + offset, "\r\n");
    } else if (strcmp(type, "POST") == 0){
      offset += sprintf(request_buffer + offset, "POST %s HTTP/1.1\r\n", destination);
      offset += sprintf(request_buffer + offset, "Host: %s\r\n", host);
      offset += sprintf(request_buffer + offset, "Content-Type: application/x-www-form-urlencoded\r\n");
      offset += sprintf(request_buffer + offset, "Content-Length: %d\r\n\r\n", strlen(body));
      offset += sprintf(request_buffer + offset, body);
    }
    Serial.println("trying to send request");
    send_http_request(host, request_buffer, 1000, 6000, true);
  }
  
  uint8_t App::char_append(char* buff, char c, uint16_t buff_size) {
    int len = strlen(buff);
    if (len > buff_size) return false;
    buff[len] = c;
    buff[len + 1] = '\0';
    return true;
  }
  
  void App::send_http_request(char* host, char* request, uint16_t response_size, uint16_t response_timeout, uint8_t serial) {
    WiFiClient client; // WiFiClient object
    if (client.connect(host, 80)) { // try to connect to host on port 80
      if (serial) Serial.println(request); // Can do one-line if statements in C without curly braces
      client.print(request);
      memset(response, 0, response_size); // Null out (0 is the value of the null terminator '\0') entire buffer
      uint32_t count = millis();
      while (client.connected()) { // while we remain connected read out data coming back
        client.readBytesUntil('\n',response,response_size);
        if (serial) Serial.println(response);
        if (strcmp(response,"\r")==0) { // found a blank line!
          break;
        }
        memset(response, 0, response_size);
        if (millis()-count>response_timeout) break;
      }
      memset(response, 0, response_size);  
      count = millis();
      while (client.available()) { // read out remaining text (body of response)
        char_append(response, client.read(), response_size);
      }
      if (serial) Serial.println(response);
      client.stop();
      if (serial) Serial.println("-----------");  
    } else{
      if (serial) Serial.println("connection failed :/");
      if (serial) Serial.println("wait 0.5 sec...");
      client.stop();
    }
  }
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
App.h C++ Code
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
/*
  App.h - Library for the App superclass. Handles user input and HTTP requests.
*/
#ifndef App_h
#define App_h
#include <memory>
#include "Arduino.h"
#include "Inputs/Button/Button.h"

class App {
  private:
    void send_http_request(char* host, char* request, uint16_t response_size, uint16_t response_timeout, uint8_t serial);
    uint8_t char_append(char* buff, char c, uint16_t buff_size);
  protected:
    // user button inputs
    uint8_t button_input_one;
    uint8_t button_input_two;
    uint8_t button_input_three;
    // http request
    char response[1000];
    void http_request(char* type, char* body, char* destination, char* host);
  public:
    App();
    void get_user_input();
    virtual uint8_t handle_user_input();
    virtual void draw_screen();
};

#endif
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Button.cpp C++ Code
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
#include "Arduino.h"
#include "Button.h"

Button::Button(uint8_t button_pin) {  
  flag = 0;  
  state = 0;
  pin = button_pin;
  state_2_start_time = millis();
  button_change_time = millis();
  debounce_duration = 10;
  long_press_duration = 1000;
  button_pressed = 0;
}

void Button::read(){
  uint8_t button_state = digitalRead(pin);  
  button_pressed = !button_state;
}

uint8_t Button::update_state() {
  read();
  flag = 0;
  if (state==0) {
    if (button_pressed) {
      state = 1;
      button_change_time = millis();
    }
  } else if (state==1) {
    if (!button_pressed) {
      state = 0;
      button_change_time = millis();
    } else {
      if (millis()-button_change_time >= debounce_duration) {
        state = 2;
        state_2_start_time = millis();
      }
    }
  } else if (state==2) {
    if (!button_pressed) {
      state = 4;
      button_change_time = millis();
    } else {
      if (millis()-state_2_start_time >= long_press_duration) {
        state = 3;
      }
    }
  } else if (state==3) {
    if (!button_pressed) {
      state = 4;
      button_change_time = millis();
    }
  } else if (state==4) {        
    if (!button_pressed) {
      if (millis()-button_change_time >= debounce_duration) {
        state = 0;
        if (millis()-state_2_start_time >= long_press_duration) {
          flag = 2;
        } else {
          flag = 1;
        }
      }
    } else {
      if (millis()-state_2_start_time >= long_press_duration) {
        state = 3;
      } else {
        state = 2;
      }
      button_change_time = millis();
    }
  }
  return flag;
}
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Button.h C++ Code
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
/*
  Button.h - Library for handling button inputs.
*/
#ifndef Button_h
#define Button_h
#include "Arduino.h"

class Button {
  private:
    uint32_t state_2_start_time;
    uint32_t button_change_time;    
    uint32_t debounce_duration;
    uint32_t long_press_duration;
    uint8_t pin;
    uint8_t flag;
    bool button_pressed;
    uint8_t state;
    void read();
  public:
    Button(uint8_t button_pin);
    uint8_t update_state();
};

#endif
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Keyboard.cpp C++ Code
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
#include "Arduino.h"
#include "Phone.h"
#include "Keyboard.h"

Keyboard::Keyboard() {
    horizontal_select_state = 0;
    vertical_select_state = 0;
}

bool Keyboard::handle_user_input(uint8_t button_input_one, uint8_t button_input_two, uint8_t button_input_three) {
    if (button_input_two == 1 || button_input_two == 2) {
        // vertical scroll
        if (vertical_select_state < 3) {
            vertical_select_state++;
        } else {
            vertical_select_state = 0;
        }
    }
    if (button_input_one == 1 || button_input_one == 2) {
        // horizontal scroll
        if (horizontal_select_state < 6) {
            horizontal_select_state++;
        } else {
            horizontal_select_state = 0;
        }
    }
    if (button_input_three == 1) {
        // enter a character
        char *current_character = letters_array[vertical_select_state*7 + horizontal_select_state];
        if (current_character == "N") {
            return true;
        } else if (current_character == "D") {
            if (offset > 0) {
                sprintf(current_message + offset - 1, " ");
                offset--;
            }
        } else {
            offset += sprintf(current_message + offset, "%s", current_character);
        }
    }
    Serial.println(current_message);
    return false;
}

char* Keyboard::get_current_message() {
    return current_message;
}

void Keyboard::reset_message() {
    horizontal_select_state = 0;
    vertical_select_state = 0;
    offset = 0;
    sprintf(current_message, "");
}

void Keyboard::draw_screen() {
    tft.setTextSize(1);
    tft.setTextColor(TFT_WHITE, TFT_BLACK); // set color of font to white foreground, black background
    
    for (int i = 0; i < 4; i++) {
        for (int j = 0; j < 7; j++) {
            if (i == vertical_select_state && j == horizontal_select_state) {
                tft.setTextColor(TFT_BLACK, TFT_WHITE); // set color of font to black foreground, white background
                tft.drawString(letters_array[i*7+j], 29+j*10, 96+i*16);
                tft.setTextColor(TFT_WHITE, TFT_BLACK); // set color of font to white foreground, black background
            } else {
                tft.drawString(letters_array[i*7+j], 29+j*10, 96+i*16);
            }
        }
    }
}
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Keyboard.h C++ Code
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
/*
  Keyboard.h - Library for a keyboard interface. Allows users to type messages.
*/

#ifndef Keyboard_h
#define Keyboard_h
#include "Arduino.h"

// letters
static char *letters_array[28] = {"a", "b", "c", "d", "e", "f", "g", 
                                "h", "i", "j", "k", "l", "m", "n", 
                                "o", "p", "q", "r", "s", "t", "u", 
                                "v", "w", "x", "y", "z", "N", "D"};

class Keyboard {
  private:
    char current_message[300];
    uint8_t horizontal_select_state;
    uint8_t vertical_select_state;
    uint8_t offset;
  public:
    Keyboard();
    bool handle_user_input(uint8_t button_input_one, uint8_t button_input_two, uint8_t button_input_three);
    char* get_current_message();
    void draw_screen();
    void reset_message();
};

#endif
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

<!-- Markdeep: --><style class="fallback">body{visibility:hidden;white-space:pre;font-family:monospace}</style><script src="markdeep.min.js" charset="utf-8"></script><script src="https://morgan3d.github.io/markdeep/latest/markdeep.min.js?" charset="utf-8"></script><script>window.alreadyProcessedMarkdeep||(document.body.style.visibility="visible")</script>

