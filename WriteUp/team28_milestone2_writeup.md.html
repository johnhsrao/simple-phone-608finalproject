                    <meta charset="utf-8" emacsmode="-*- markdown -*">
                    **6.08 Final Project Week2 Write UP - Team 28**
        John Rao, Kameron Dawson, Camila Miranda-Llovera, Umang Bansal, Nick Dyette



Deliverables
===============================================================================
Below is how we addressed each deliverable:

1. Implement the Weather App
2. Implement the Clock App
3. Improve the Messaging App
4. 
5. 
6. Improve the Game App

Weather App
================================================================================
Specifications:

1. User can check and display the weather at their current location.
2. User can check and display the weather at other locations of their choice.


Server 
-------------------------------------------------------------------------------
We did not use any server code for this application. 

ESP
-------------------------------------------------------------------------------
Implementation:

1. The way we implemented this application is by creating a state machine with 3 states. A state whether the user wants to display the weather at their location or another location, a state for inputting the other location, and a state for displaying the weather info. Upon entering the app, the system is in the 1st state, and prompts the user by displaying which buttons to press. If the user selects their current location, the ESP makes a GET Request to the OpenWeather API through the getWeather() function, with Boston as the location. If the user selects a different location, we enter the SELECT_PLACE state, and interface with the keyboard input system to allow the user to input their own city, we then perform the same request with the city as the location. Within our GET Request function, store the respone buffer in a JSON object, and then store the key values: temperature, humidity, and weather, in variables. We then enter the DISPLAY_INFO state, and display the 3 variables for the user. 

<iframe width="560" height="315" src="https://www.youtube.com/embed/Y7PnVkVBfzo" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>

Code Appendix
-------------------------------------------------------------------------------
Weather App getWeather() and handle_user_input() functions
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t WeatherApp::handle_user_input() {
    if(weather_state == SELECT_MENU){
        if(button_input_one > 0){
            getWeather("Boston");
            sprintf(city, "Boston");
            weather_state = DISPLAY_INFO;
            prev_state = SELECT_MENU;
        }
        else if(button_input_two > 0){
            weather_state = SELECT_PLACE;
            prev_state = SELECT_MENU;
        }
    }
    else if(weather_state == SELECT_PLACE){
        if(keyboard.handle_user_input(button_input_one, button_input_two, button_input_three)){
            sprintf(input, "%s", keyboard.get_current_message());
            getWeather(input);
            sprintf(city, "%s", input);
            weather_state = DISPLAY_INFO;
            prev_state = SELECT_PLACE;
        }
    }
    else if(weather_state == DISPLAY_INFO){
        if((button_input_one> 0) or (button_input_two > 0) or (button_input_three ==  1)){
            weather_state = SELECT_MENU;
            prev_state = DISPLAY_INFO;
        }
    }
    if (button_input_three == 2) {
        return HOME; // switch to the home app
    } else {
        return NO_CHANGE; // stay on the weather app
    }
}

void WeatherApp::getWeather(char* input){
    char query[300];
    sprintf(query, "q=%s&units=imperial&appid=801e3a740d19f1a6fa24099785bae7d4", input);
    http_request("GET",
        query,
        "/data/2.5/weather",
        "api.openweathermap.org");
    char* first_curly = strchr(response, '{');
    char* end_curly = strrchr(response, '}');
    *(end_curly + 1) = NULL;
    DeserializationError error = deserializeJson(responsedoc, first_curly);
    if(error){
        Serial.print(F("deserializeJson()failed: "));
        Serial.println(error.f_str());
    }
    double temp = responsedoc["main"]["temp"];
    int humid = responsedoc["main"]["humidity"];
    sprintf(temperature, "%f", temp);
    sprintf(humidity, "%d", humid);
    strncpy(weather, responsedoc["weather"][0]["description"], 30);
}
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Clock App
================================================================================
Specifications:
1. User can access the correct time at their location
2. User can switch between digital time and analog clock time


ESP
-------------------------------------------------------------------------------
The code makes periodic GET requests to the server iesc-s3.mit.edu/esp32test/currenttime to get the current time and because the response always has the same format, we can use the string class to extract the appropriate hours, minutes, and seconds. The clock can then display the hours and seconds in the digital version or use cos and sin on the hours, minutes, and seconds numbers to determine the correct angle of the clock hands in the analog version.

To determine whether to show the digital or analog version, the code defines a state machine with four states. They are digital, digital_down, clock, and clock_down. In the handle_user_input function, whenever the enter button is short-pressed, the state moves to the next state (either digital_down or clock_down) and when it is unpressed, it moves to the next state (clock or digital). In digital and digital_down, a boolean is set to true, otherwise it is false. Draw_screen calls print_digital or print_analog depending on the value of the boolean.

Code Appendix
C ++ State machine
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
if (state ==  DIGITAL) {
        digital = true;
        if (button_input_three==0) {
            state = DIGITAL_DOWN;
        }
    } else if (state == DIGITAL_DOWN) {
        if (button_input_three==1) {
            tft.fillScreen(TFT_BLACK);
            state = CLOCK;
        } else {
            digital = true;
        }
    } else if (state == CLOCK) {
        digital = false;
        if (button_input_three==0) {
            state = CLOCK_DOWN;
        }
    } else {
        if (button_input_three==1) {
            tft.fillScreen(TFT_BLACK);
            state = DIGITAL;
        } else {
            digital = false;
        }
    }
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

C++ code to print digital and analog
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
void ClockApp::print_digital() {
    memset(displayed_time, 0, strlen(displayed_time));
    if ((times[2] + (millis() - timer) / 1000) >= 60) {
        if ((times[1] + 1) >= 60) {
            sprintf(displayed_time, "%d:%d     ", (int) (times[0] + 1)%12, (int) times[1] - 59);
        } else if (times[1]+1 > 9) {
            sprintf(displayed_time, "%d:%d     ", (int) (times[0])%12, (int) times[1] + 1);
        } else {
            sprintf(displayed_time, "%d:0%d     ", (int) (times[0])%12, (int) times[1] + 1);
        }
    } else {
        if (times[1]+1 > 9) {
            sprintf(displayed_time, "%d:%d     ", (int) (times[0])%12, (int) times[1] + 1);
        } else {
            sprintf(displayed_time, "%d:0%d     ", (int) (times[0])%12, (int) times[1]);
        }
    }
    tft.drawString(displayed_time, 0, 0, 1);
  }

void ClockApp::print_analog() {
    if (millis() -  timer2 > 1000) {
        float new_sec = times[2] + (millis() - timer) / 1000;
        float new_min = times[1];
        float new_hours = times[0];
        if (new_sec >= 60) {
            new_min += 1;
            new_sec -= 60;
        }
        if (new_min >= 60) {
            new_hours += 1;
            new_min -= 60;
        }
        if (new_hours>=12) {
            new_hours -= 12;
        }
        tft.fillScreen(TFT_BLACK);
        tft.drawCircle(60, 60, 40, TFT_GREEN);
        //draw hours
        tft.drawLine(cos((new_hours*30 + new_min/2)*PI/180 - PI/2)*20 + 60, sin((new_hours * 30 + new_min/2)*PI/180 - PI/2)*20 + 60, 60, 60, TFT_GREEN);
        //draw minutes
        tft.drawLine(cos(new_min * 6*PI/180 - PI/2)*30 + 60, sin(new_min * 6*PI/180 - PI/2)*30 + 60, 60, 60, TFT_GREEN);
        //draw seconds
        tft.drawLine(cos(new_sec * 6*PI/180 - PI/2)*35 + 60, sin(new_sec * 6*PI/180 - PI/2)*35 + 60, 60, 60, TFT_GREEN);
        timer2 = millis();
    }
}
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<iframe width="560" height="315" src="https://www.youtube.com/embed/l0tDNa6G3pk" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>



Messaging App Update
================================================================================
Specifications:
1. Resolve previous parsing issues when displaying messages
2. Build a more robust and adpatable way to parse messaging history that can be used later in other apps
3. Include a scrolling functionality the check message history function to allow users to scroll through a long history
4. Make the UI of the app more intuitive and follow the button conventions used throughout other apps


Server Update
-------------------------------------------------------------------------------
The server side of the messaging app works mostly the same as implemented last week. However, for POST requests to check messages the server now returns a dictionary in as JSON formatted strings instead of nested lists of messages to allow us to build a more robust and flexible way to parse and extract different information from thr server response. Specifically, the server response is now formatted like is a dictionary thats looks like this *{"(index of message ordered by time)":{"date":"(time message was sent/receivd)", "message": "(sender: message)""}, "end": "These are the last {} messages between you and {}".format(num_msg, user_other), "length": (number of messages returned)}*. The part of the server code creates the dictionary is shown below:

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
def insert_dict(d, msg, sender):
    output = dict()
    output['date'] = d[5:16]
    output['message'] = sender + ": " + msg
    return output

if len(sent_messages) == 0 and len(received_messages) == 0:
    return_dict = dict()
    return_dict['end'] = "There are no messages between you and {}".format(user_other)
    return_dict['length'] = 0
    return json.dumps(return_dict, indent=4)
for i in range(num_msg):
    if len(sent_messages) >= 1 and len(received_messages) >= 1:
        if sent_messages[0] > received_messages[0]:
            selected = sent_messages.pop(0)
            return_dict[i+1] = insert_dict(selected[0], selected[2], "Me")
            length = i + 1
        elif received_messages[0] >= sent_messages[0]:
            selected = received_messages.pop(0)
            return_dict[i+1] = insert_dict(selected[0], selected[2], user_other)
            length = i + 1
    elif len(sent_messages) >= 1:
        selected = sent_messages.pop(0)
        return_dict[i+1] = insert_dict(selected[0], selected[2], "Me")
        length = i + 1
    elif len(received_messages) >= 1:
        selected = received_messages.pop(0)
        return_dict[i+1] = insert_dict(selected[0], selected[2], user_other)
        length = i + 1
    else:
        break
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

ESP Update
-------------------------------------------------------------------------------
On the ESP side, there were a few isssues when displaying unread messages and message history last week. First issue was that there were randome characters floating on the top of the screen when displaying messages. This was actually cause by an incorrect state transition in *uint8_t MessagingApp::handle_user_input()* not the function that parses the server reponse, which made the ESP print some unparsed parts of the server response after printing the messages. This issue then been fixed. 

In order to more easily extract different information like time and sender from the server response and make the message display more readable, we modified to server reponse to be in JSON format like previously discussed. Thus we wrote a new parsing function that extracts these information by first using the *deserializeJson* function in ArduinoJson library to convert the server response to a JSON object. Since in the JSON object we can get the number of messages by using the *length* key, we know the range of indices we need to iterate through to get each message's *date* and *message*. The parsing and displaying of messages is handled by *message_parsing()* which takes the deserialized JSON and the starting index of the messages to be drawn as input. The starting index, *next_msg*,is used when implementing the scrolling functionality, which will be discussed more in detail later. *message_parsing* gets called in the *void MessagingApp::draw_screen()* when the system is in *DISPLAY_MESSAGE* state. Code for *message_parsing* is shown here:

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
void MessagingApp::message_parsing(StaticJsonDocument<3000> &doc, int next_msg){
    tft.fillScreen(TFT_BLACK);
    uint8_t yPos = 150;
    uint16_t body_length = doc["length"];
    if(body_length > 0){
        for(int i = next_msg; i <= body_length; i++){
            Serial.println("in for loop");
            char key[2];
            memset(key, 0, sizeof(key));
            itoa(i, key, 10);
            char date[20];
            sprintf(date, doc[key]["date"]);
            char message[3000];
            sprintf(message, doc[key]["message"]);
            yPos = new_yPos(yPos,5,message);
            if(yPos < 30){
                tft.setTextColor(TFT_BLUE);
                tft.setCursor(5, 5);
                tft.println("RIGHT to Scroll Up");
                tft.setCursor(5, 15);
                tft.println("DOWN to Scroll Down");
                tft.setTextColor(TFT_WHITE);
                more_msg = true;
                break;
            }
            uint8_t last_y = drawMessages(date, message, yPos);
            yPos = last_y;
        }
        if(more_msg != true){
            tft.setTextColor(TFT_BLUE);
            tft.setCursor(5, 5);
            tft.println(doc["end"]);
            tft.setTextColor(TFT_WHITE);
        }
    }
    else{
        char date[5];
        sprintf(date, " ");
        char message[200];
        sprintf(message, doc["end"]);
        drawMessages(date, message, yPos);
    }
}
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Note that here *message_parsing* also calls a function *drawMessage* which is a helper function that prints the *date* in grey and *message* sent by the user in green and *message* received by the user in white. The input *yPos* is the y position of where the input message will start printing. *yPos* is computed by *new_yPos* which was previously called at each iteration by *message_parsing*. is The code for *drawMessage* and *new_yPos* is shown here:

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t MessagingApp::drawMessages(char* d, char* msg, uint8_t yPos){
    char sender[10];
    sprintf(sender, "%c", msg[0]);
    sprintf(sender + strlen(sender), "%c", msg[1]);
    if(strcmp(sender, "Me")==0){
        tft.setTextColor(TFT_GREEN, TFT_BLACK);
    }
    tft.setCursor(5, yPos);
    tft.println(msg);
    if(strcmp(d, " ")!=0){
        tft.setTextColor(0x7BEF, TFT_BLACK);
        tft.setCursor(5, yPos - 10);
        tft.println(d);

    }
    tft.setTextColor(TFT_WHITE, TFT_BLACK);
    int curr_y = tft.getCursorY();
    return curr_y;
}

uint8_t MessagingApp::new_yPos(uint8_t y, uint8_t x_start, char* msg){
    uint16_t msg_length = strlen(msg);
    uint8_t max_num = (SCREEN_WIDTH - x_start) / CHAR_WIDTH;
    uint8_t num_lines = msg_length / max_num;
    uint8_t num_pix = (num_lines+1)*(CHAR_HEIGHT+2)+10;
    uint8_t new_y = y - num_pix;
    return new_y;
}

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

The scrolling functionality allows user to scroll up and down when all messages returned by the server cannot be displayed on the screen at once. Specifically, the user would press RIGHT (*button_input_one*) to scroll up and press DOWN(*button_input_two*) to scroll down. We defined 3 new class variables (*bool msg_display_updated, bool more_msg, uint8_t msg_index*) to keep track of what we should be printing to the screen. As previously mentioned, *msg_index* is passed into *message_parsing* as an parameter(*next_msg*) to set the starting point of the for loop that extracts the messages to print to screen. *more_msg* is initialized to false and set to true in *message_parsing* if there are messages that are not displayed on the screen yet. Whenever button one is pressed and *more_msg* evaluates to true while displaying messages, *msg_index* would increment by 1. Similarly, when button two is pressed and *msg_index > 1* evaluates to true, *msg_index* would decrease by 1. This is all handled in the *DISPLAY_MESSAGE* state of *uint8_t MessagingApp::handle_user_input()*. Note that all messages are printed starting from the bottom of the screen, so incrementing *msg_index* would essentially shift all messages down, vice versa. Whenever these buttons are pressed, *msg_display_updated* would be set to false which will let *void MessagingApp::draw_screen()* call *massage_parsing* again with a new starting index to extract and print a new set of messages. Code for *DISPLAY_MESSAGE* state of *handle_user_input()* and *draw_screen()* are shown here:

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t MessagingApp::handle_user_input() {
//code omitted here
      else if(text_state==DISPLAY_MESSAGE){
        if(button_input_three == 1){
            text_state = SELECT_MENU;
            prev_state = DISPLAY_MESSAGE;
            msg_index = 1; 
        }
        else if(button_input_one > 0 && more_msg == true){
            Serial.println("scroll up");
            msg_index ++;
            msg_display_updated = false;
            more_msg = false;
        }
        else if(button_input_two > 0 && msg_index > 1){
            Serial.println("scroll down");
            msg_index --;
            msg_display_updated = false;
        }
    }
// more code
}

void MessagingApp::draw_screen() {
//code omitted here
    else if(text_state==DISPLAY_MESSAGE){
        if(prev_state != DISPLAY_MESSAGE){
            tft.fillScreen(TFT_BLACK);
        }
        if((prev_state == SELECT_MESSAGE) or (prev_state == SELECT_MENU)){
            deserializeJson(parsed_doc, response);
            message_parsing(parsed_doc, 1);
        }
        else if(prev_state == SEND_MESSAGE){
            tft.setCursor(10, 10);
            tft.println(response);
        }
        if(msg_display_updated != true){
            message_parsing(parsed_doc, msg_index);
            msg_display_updated = true;
        }
        prev_state = DISPLAY_MESSAGE;
    }
}
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
There are a few other UI updates to the messaging app. First, the select menu of the app now also gives the user the option to select an action directly from a list of options on the screen by using the DOWN button (button 2). The current selected option would be highlighted in green. If there are no new messages the option for View All Unread would be greyed out. This makes the select menu more intuitive and follows the convention of the buttons in other apps. Like previously, user can still select an action by using a single button short cut (Long press button one to check history, long press button two to view all new messages, short press button one to send a message). In other states (*SEND_MESSAGE* and *SELECT_MESSAGE*), other UI features like highlighted text boxes and captions are also add to make the UI more intuitive. This update also uses the new keyboard implementation so that now the user can enter numbers, spaces, etc. Having numbers on the keyboard, we are able to let the user choose how many messages they want to view when they are checking message history. 

Video of Updated Messaging App
--------------------------------------------------------------------------------
<iframe width="560" height="315" src="https://www.youtube.com/embed/fvtZwkl5G3k" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>

Other Updated C++ Code for UI:
--------------------------------------------------------------------------------
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t MessagingApp::handle_user_input() {
    if (text_state == SELECT_MENU){// main menu 
        //select option on screen using DOWN button (button 2)
        if (button_input_two == 1){
            select_state ++;
            if(select_state > SELECT_HISTORY){
                if(unread_num > 0){
                    select_state = SELECT_UNREAD;
                }
                else{
                    select_state = SELECT_SEND;
                }
            }
        }
        else if(button_input_three == 1){
            if(select_state == SELECT_UNREAD){
                checkUnreadMessages();
                text_state = DISPLAY_MESSAGE;
                prev_state = SELECT_MENU;
            }
            else if(select_state == SELECT_SEND){
                text_state = SEND_MESSAGE;
                prev_state = SELECT_MENU;
                otherSelected = false;
                messageSelected = false;
            }
            else if(select_state == SELECT_HISTORY){
                text_state = SELECT_MESSAGE;
                prev_state = SELECT_MENU;
            }
        }
        //single button shortcuts
        else if(button_input_one == 1){
            text_state = SEND_MESSAGE;
            prev_state = SELECT_MENU;
            otherSelected = false;
            messageSelected = false; 
        }
        else if(button_input_one == 2){
            text_state = SELECT_MESSAGE;
            prev_state = SELECT_MENU;
        }
        else if(button_input_two == 2 && unread_num > 0){
            checkUnreadMessages();
            text_state = DISPLAY_MESSAGE;
            prev_state = SELECT_MENU;
        }
        if(millis()-timer >= notif_period){
            checkUnreadNum();
            unread_num = atoi(response);
            timer = millis();
        }
    }
        // more code omitted here
}

//highlight selected option in main menu
void MessagingApp::draw_selected(uint8_t selection, uint8_t prev){
    if(selection == SELECT_SEND){
        tft.fillRect(8, 55, 114, 28, TFT_GREEN);
    }
    else if(selection == SELECT_HISTORY){
        tft.fillRect(8, 85, 114, 28, TFT_GREEN);
    }
    else if(selection == SELECT_UNREAD){
        tft.fillRect(8, 25, 114, 28, TFT_GREEN);
    }
    if(prev == SELECT_SEND){
        tft.fillRect(8, 55, 114, 28, TFT_BLACK);
    }
    else if(prev == SELECT_HISTORY){
        tft.fillRect(8, 85, 114, 28, TFT_BLACK);
    }
    else if(prev == SELECT_UNREAD){
        tft.fillRect(8, 25, 114, 28, TFT_BLACK);
    }
}
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Game App Update
================================================================================
Specifications:

Initially, the objects on our screen were flickering because we filled the screen at every loop. This was how we updated the location of the ball based on user input, and how we moved the obstacles across the screen. Our main task this week was:
	- fix the flickering of the screen

Implementation
-------------------------------------------------------------------------------
The main idea behind this implementation is that rather than fill the screen everytime, we would instead draw the objects at their new position and cover up the remaining pixels from the previous drawing. This was done in our draw_screen function. Our first action was to draw the images used to cover up past obstacles. Afterwards, we would draw the new positions of the objects that changed after every call to handle_user_input. Two new variables, old_locy and old_locx, helped us keep track of where to cover up any unwanted pixels. For example, if loc_y was one pixel greater than old_locy, we would draw a rectangle of height 1 and the width of the volleyball at old_locy. We also found that in the previous iteration, tft.fillScreen had acted as a delay function to slow down the iterations. When we no longer used tft.fillScreen, our objects moved too quickly. Therefore, we introduced a timer variable, and after every 50 ms, we would redraw the screen.



Code Appendix
-------------------------------------------------------------------------------
Code update:
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
if (!over && millis() - timer > 50) {
	delay(50);
	tft.fillRect(obs2_x + obs2_width, obs2_y, 1, obs2_height, TFT_WHITE); 
	tft.fillRect(obs1_x + obs1_width, obs1_y, 1, obs1_height, TFT_WHITE);
	
	if (old_locy - loc_y > 0){
		tft.fillRect(loc_x, loc_y + volleyball_height, volleyball_width, 20, TFT_WHITE);
	}else{
		tft.fillRect(old_locx, old_locy, volleyball_width, 1, TFT_WHITE);
	}
	tft.pushImage(loc_x, loc_y, volleyball_width, volleyball_height, volleyball);
	

    if (choose1 <= 0.5) {
    	tft.pushImage(obs1_x, obs1_y, volley_width, volley_height, volleynet);
		
    } else {
    	tft.pushImage(obs1_x, obs1_y, bird_width, bird_height, bird);
    }
    if (choose2 <= 0.5) {
    	tft.pushImage(obs2_x, obs2_y, volley_width, volley_height, volleynet);
    } else {
    	tft.pushImage(obs2_x, obs2_y, bird_width, bird_height, bird);
    }
	timer = millis();

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

<iframe width="560" height="315" src="https://www.youtube.com/embed/jb4JH5l1kxU" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>

Keyboard Update
================================================================================
Specifications:

Expand the keyboard to include:
    - upper and lower case letters
    - numbers
    - spacebar
    - symbols

Implementation
-------------------------------------------------------------------------------
    - There are three possible keyboards to display: lower case letters, upper case letters, and numbers/symbols. The first two keyboards also include a button labeled "UC" and "LC", respectively, to toggle the capitalization of the letters.
    - Each keyboard has is split into four lines of characters. The last entry on each row is a button, so in order there are the buttons "123/ABC", "space", "delete", and "enter". The first button toggles between the letters keyboards and the numbers/symbols keyboard. The second button is the space character. The third button deletes an entered character. The fourth button enters the currently typed message.

Code Appendix
-------------------------------------------------------------------------------
Code update:
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Keyboard::Keyboard() {
    horizontal_select_state = 0;
    vertical_select_state = 0;
    current_keyboard = 0;
    offset = 0;
}

bool Keyboard::handle_user_input(uint8_t button_input_one, uint8_t button_input_two, uint8_t button_input_three) {
    if (button_input_two == 1 || button_input_two == 2) {
        // vertical scroll
        if (vertical_select_state < 2) {
            vertical_select_state++;
        } else if (vertical_select_state == 2) {
            vertical_select_state++;
            if (horizontal_select_state >= 6 && current_keyboard != 2) {
                horizontal_select_state--;
            }
        } else {
            vertical_select_state = 0;
            if (horizontal_select_state == 6 && current_keyboard != 2) {
                horizontal_select_state = 7;
            }
        }
    }
    if (button_input_one == 1 || button_input_one == 2) {
        // horizontal scroll
        if (vertical_select_state == 3 && current_keyboard != 2) {
            if (horizontal_select_state < 6) {
                horizontal_select_state++;
            } else {
                horizontal_select_state = 0;
            }
        } else {
            if (horizontal_select_state < 7) {
                horizontal_select_state++;
            } else {
                horizontal_select_state = 0;
            }
        }
    }
    if (button_input_three == 1) {
        uint8_t horizontal_limit;
        if (vertical_select_state == 3 && current_keyboard != 2) {
            horizontal_limit = 5;
        } else {
            horizontal_limit = 7;
        }

        if (horizontal_select_state < horizontal_limit) {
            // enter a character into the message
            char *current_character = keyboards[current_keyboard][vertical_select_state*7 + horizontal_select_state];
            offset += sprintf(current_message + offset, "%s", current_character);
        } else {
            // click a button
            if (vertical_select_state == 0) {
                // switch between letters and numbers/symbols
                if (current_keyboard != 2) {
                    current_keyboard = 2;
                } else {
                    current_keyboard = 0;
                }
            } else if (vertical_select_state == 1) {
                // spacebar
                offset += sprintf(current_message + offset, " ");
            } else if (vertical_select_state == 2) {
                // delete a character
                if (offset > 0) {
                    sprintf(current_message + offset - 1, "\0");
                    offset--;
                }
            } else {
                if (horizontal_select_state == 5) {
                    // switch between upper and lower case
                    if (current_keyboard != 2) {
                        current_keyboard = !current_keyboard;
                    }
                } else {
                    // enter the message
                    return true;
                }
            }
        }
    }
    Serial.println(current_message);
    return false;
}

char* Keyboard::get_current_message() {
    return current_message;
}

void Keyboard::reset_message() {
    horizontal_select_state = 0;
    vertical_select_state = 0;
    current_keyboard = 0;
    offset = 0;
    sprintf(current_message, "");
}

void Keyboard::draw_screen() {
    tft.setTextSize(1);

    for (int i = 0; i < 4; i++) {
        for (int j = 0; j < 7; j++) {
            if (i == vertical_select_state && j == horizontal_select_state) {
                tft.fillRect(2+j*12, 102+i*14, 10, 12, TFT_WHITE);
                tft.setTextColor(TFT_BLACK, TFT_WHITE); // set color of font to black foreground, white background
                tft.drawString(keyboards[current_keyboard][i*7+j], 2+j*12+2, 102+i*14+2);
            } else {
                tft.fillRect(2+j*12, 102+i*14, 10, 12, TFT_KEY_GRAY);
                tft.setTextColor(TFT_WHITE, TFT_KEY_GRAY); // set color of font to white foreground, gray background
                tft.drawString(keyboards[current_keyboard][i*7+j], 2+j*12+2, 102+i*14+2);
            }
            if (i == 3 && j == 4 && current_keyboard != 2) {
                break;
            }
        }
    }

    for (int i = 0; i < 4; i++) {
        if (i == 3) {
            if (current_keyboard != 2) {
                // draw the upper/lower case button
                if (vertical_select_state == i && horizontal_select_state == 5) {
                    tft.fillRect(62, 102+i*14, 22, 12, TFT_WHITE);
                    tft.setTextColor(TFT_BLACK, TFT_WHITE); // set color of font to black foreground, white background
                } else {
                    tft.fillRect(62, 102+i*14, 22, 12, TFT_KEY_GRAY);
                    tft.setTextColor(TFT_WHITE, TFT_KEY_GRAY); // set color of font to white foreground, gray background
                }
                tft.drawString(case_buttons[current_keyboard], 67, 102+i*14+2);
            } else {
                // removes the middle part of the case button that was leftover
                tft.fillRect(72, 102+i*14, 2, 12, TFT_BLACK);
            }
        }
        // draw the switch, space, delete, or enter buttons
        uint8_t horizontal_limit;
        if (i == 3 && current_keyboard != 2) {
            horizontal_limit = 6;
        } else {
            horizontal_limit = 7;
        }
        if (vertical_select_state == i && horizontal_select_state == horizontal_limit) {
            tft.fillRect(86, 102+i*14, 40, 12, TFT_WHITE);
            tft.setTextColor(TFT_BLACK, TFT_WHITE); // set color of font to black foreground, white background
        } else {
            tft.fillRect(86, 102+i*14, 40, 12, TFT_KEY_GRAY);
            tft.setTextColor(TFT_WHITE, TFT_KEY_GRAY); // set color of font to white foreground, gray background
        }
        if (i == 0) {
            tft.drawString(switch_buttons[current_keyboard], 88+9, 102+i*14+2);
        } else {
            if (i == 2) {
                tft.drawString(buttons[i-1], 88+1, 102+i*14+2);
            } else {
                tft.drawString(buttons[i-1], 88+4, 102+i*14+1);
            }
        }
    }
}

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

See video for login screen.

Login Screen
================================================================================
Specifications:

Add a login screen that is the first view on the phone. The user:
    - enters their WiFi network and password so the credentials no longer have to be hardcoded
    - logins into the phone with their username and password OR
    - creates new user on the phone with a username and password

The purpose of the login screen is to add a layer of protection to a user's data (texts, emails, etc), and also so we can know who is currently using the device for the purpose of texting, emailing, kepping track of game high score, etc.

Implementation
-------------------------------------------------------------------------------
    - State machine to know which screen to display: enter WiFi credentials screen, choose to login or create new user screen, login screen, and create new user screen.
    - Enter WiFi credentials screen has two textboxes labeled "network:" and "password:", respectively. There is also a butten labeled "submit". The user can scroll between these three objects. If they click on either of the textboxes it opens up the keyboard and allows them to type in the box. If they click the button it submits the WiFi credentials and attempts to connect to the network. If it fails it displays a message "incorrect"; otherwise it switches to the choose to login or create new user screen.
    - Choose to login or create new user screen has two buttons labeled "login" and "new user". Clicking the first button takes the user to the login screen. The second button takes the user to the new user screen.
    - Login screen has two textboxes labeled "username:" and "password:", operating the same as in the WiFi screen. There is also a button labeled "submit" that when clicked sends the text currently entered into the textbox to the server with a HTTP POST request to check if the username and password are correct. If so it takes them to the home screen of the phone; otherwise it displays a message saying it's incorrect. There is also a button labeled "back", which takes the user back to the choose to login or new user screen.
    - New user screen is the exact same as the login screen except it sends its POST request to a different endpoint to create a user rather than check if it already exists.

Code Appendix
-------------------------------------------------------------------------------
Code update:
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
LoginApp::LoginApp() {
    screen_state = 0;  
    vertical_select_state = 0;
    horizontal_select_state = 0;
    state_change = true;
    show_keyboard = false;
    incorrect_input = false;
    sprintf(text_box_one, "");
    sprintf(text_box_two, "");
    keyboard.reset_message();
}

uint8_t LoginApp::handle_user_input() {
    if (!show_keyboard) {
        if (screen_state == 1) {
            if (button_input_two == 1 || button_input_two == 2) {
                // vertical scroll
                if (vertical_select_state < 1) {
                    vertical_select_state++;
                } else {
                    vertical_select_state = 0;
                }
                state_change = true;
            }
            if (button_input_three == 1) {
                // click the login or new user button
                if (vertical_select_state == 0) {
                    // switch to user login
                    screen_state = 2;
                } else {
                    // switch to new user
                    screen_state = 3;
                }
                state_change = true;
                vertical_select_state = 0;
            }
        } else {
            if (button_input_two == 1 || button_input_two == 2) {
                // vertical scroll
                if (vertical_select_state < 2) {
                    vertical_select_state++;
                } else {
                    vertical_select_state = 0;
                }
                state_change = true;
            }
            if ((screen_state == 2 || screen_state == 3) && vertical_select_state == 2) {
                if (button_input_one == 1 || button_input_one == 2) {
                    // horizontal scroll
                    if (horizontal_select_state < 1) {
                        horizontal_select_state++;
                    } else {
                        horizontal_select_state = 0;
                    }
                    state_change = true;
                }
            }
            if (button_input_three == 1) {
                if (vertical_select_state == 0 || vertical_select_state == 1) {
                    // enter text into box
                    show_keyboard = true;
                } else {
                    // submit info
                    if (screen_state == 2 || screen_state == 3) {
                        if (horizontal_select_state == 0) {
                            // go back to select login or new user
                            screen_state = 1;
                            sprintf(text_box_one, "");
                            sprintf(text_box_two, "");
                            vertical_select_state = 0;
                            horizontal_select_state = 0;
                            incorrect_input = false;
                        } else {
                            // send http post request with credentials
                            char body[55];
                            sprintf(body, "username=%s&passcode=%s", text_box_one, text_box_two);
                            char destination[65];
                            if (screen_state == 2) {
                                sprintf(destination, "/sandbox/sc/team28/final_project/python/Login/login.py");
                            } else {
                                sprintf(destination, "/sandbox/sc/team28/final_project/python/Login/create_user.py");
                            }
                            http_request("POST", body, destination, "608dev-2.net");
                            if (strncmp(response, "True", 4) == 0) {
                                // login or creation of new user was successful
                                // store username
                                sprintf(username, "%s", text_box_one);
                                // switch to home screen
                                return HOME;
                            } else {
                                // login or creation of new user was NOT successful
                                incorrect_input = true;
                            }
                        }
                    } else {
                        // connect to the internet
                        if (connect_to_internet()) {
                            screen_state = 1;
                            sprintf(text_box_one, "");
                            sprintf(text_box_two, "");
                            vertical_select_state = 0;
                            incorrect_input = false;
                        } else {
                            incorrect_input = true;
                        }
                    }
                }
                state_change = true;
            }
        }
    } else {
        if (button_input_one != 0 || button_input_two != 0 || button_input_three != 0) {
            state_change = true;
        }
        bool keyboard_enter = keyboard.handle_user_input(button_input_one, button_input_two, button_input_three);
        if (vertical_select_state == 0) {
            strncpy(text_box_one, keyboard.get_current_message(), 18);
        } else {
            strncpy(text_box_two, keyboard.get_current_message(), 18);
        }
        if (keyboard_enter) {
            keyboard.reset_message();
            show_keyboard = false;
        }
    }
    return NO_CHANGE;
}

void LoginApp::draw_screen() {
    if (state_change) {
        tft.fillScreen(TFT_HOME_SCREEN);
        if (screen_state == 1) {
            // select login or new user
            tft.setTextSize(2);
            if (vertical_select_state == 0) {
                tft.fillRect(12, 44, 104, 24, TFT_WHITE);
                tft.setTextColor(TFT_BLACK, TFT_WHITE); // set color of font to black foreground, white background
                tft.drawString("login", 12+22, 44+4);

                tft.fillRect(12, 92, 104, 24, TFT_BLACK);
                tft.setTextColor(TFT_WHITE, TFT_BLACK); // set color of font to white foreground, black background
                tft.drawString("new user", 12+4, 92+4);
            } else {
                tft.fillRect(12, 44, 104, 24, TFT_BLACK);
                tft.setTextColor(TFT_WHITE, TFT_BLACK); // set color of font to white foreground, black background
                tft.drawString("login", 12+22, 44+4);

                tft.fillRect(12, 92, 104, 24, TFT_WHITE);
                tft.setTextColor(TFT_BLACK, TFT_WHITE); // set color of font to black foreground, white background
                tft.drawString("new user", 12+4, 92+4);
            }
        } else {
            tft.setTextSize(1);

            tft.setTextColor(TFT_WHITE, TFT_HOME_SCREEN); // set color of font to white foreground, blue background
            if (screen_state == 2 || screen_state == 3) {
                // enter username and password
                tft.drawString("username:", 8, 9);
                tft.setTextColor(TFT_RED, TFT_HOME_SCREEN); // set color of font to red foreground, blue background
                if (incorrect_input) {
                    tft.drawString("incorrect", 68, 9);
                }
            } else {
                // select WiFi network and enter password
                tft.drawString("network:", 8, 9);
                tft.setTextColor(TFT_RED, TFT_HOME_SCREEN); // set color of font to red foreground, blue background
                if (incorrect_input) {
                    tft.drawString("incorrect", 68, 9);
                }
            }
            tft.fillRect(8, 24, 112, 12, TFT_WHITE);
            tft.setTextColor(TFT_BLACK, TFT_WHITE); // set color of font to black foreground, white background
            tft.drawString(text_box_one, 10, 26);

            tft.setTextColor(TFT_WHITE, TFT_HOME_SCREEN); // set color of font to white foreground, blue background
            tft.drawString("password:", 8, 45);
            tft.setTextColor(TFT_RED, TFT_HOME_SCREEN); // set color of font to red foreground, blue background
            if (incorrect_input) {
                tft.drawString("incorrect", 68, 45);
            }
            tft.fillRect(8, 60, 112, 12, TFT_WHITE);
            tft.setTextColor(TFT_BLACK, TFT_WHITE); // set color of font to black foreground, white background
            tft.drawString(text_box_two, 10, 62);

            if (screen_state == 2 || screen_state == 3) {
                tft.fillRect(16, 81, 40, 12, TFT_WHITE);
                tft.setTextColor(TFT_BLACK, TFT_WHITE); // set color of font to black foreground, white background
                tft.drawString("back", 16+8, 81+2);

                tft.fillRect(72, 81, 40, 12, TFT_WHITE);
                tft.setTextColor(TFT_BLACK, TFT_WHITE); // set color of font to black foreground, white background
                tft.drawString("submit", 72+2, 81+2);
            } else {
                tft.fillRect(42, 81, 44, 12, TFT_WHITE);
                tft.setTextColor(TFT_BLACK, TFT_WHITE); // set color of font to black foreground, white background
                tft.drawString("submit", 42+4, 81+2);
            }
            if (vertical_select_state == 0) {
                tft.drawRect(7, 23, 114, 14, TFT_BLACK);
            } else if (vertical_select_state == 1) {
                tft.drawRect(7, 59, 114, 14, TFT_BLACK);
            } else {
                if (screen_state == 2 || screen_state == 3) {
                    if (horizontal_select_state == 0) {
                        tft.drawRect(15, 80, 42, 14, TFT_BLACK);
                    } else {
                        tft.drawRect(71, 80, 42, 14, TFT_BLACK);
                    }
                } else {
                    tft.drawRect(41, 80, 46, 14, TFT_BLACK);
                }
            }
            if (show_keyboard) {
                keyboard.draw_screen();
            }
        }
        state_change = false;
    }
}

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

<iframe width="560" height="315" src="https://www.youtube.com/embed/lhTQqpsp45I" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>

<!-- Markdeep: --><style class="fallback">body{visibility:hidden;white-space:pre;font-family:monospace}</style><script src="markdeep.min.js" charset="utf-8"></script><script src="https://morgan3d.github.io/markdeep/latest/markdeep.min.js?" charset="utf-8"></script><script>window.alreadyProcessedMarkdeep||(document.body.style.visibility="visible")</script>